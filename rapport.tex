\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage[francais]{babel}
\usepackage{amsfonts} %permet d'utiliser mathbb
\usepackage{amsthm} %permet d'utiliser \newtheorem*
 \usepackage{amsmath} %permet d'utiliser les matrices
\usepackage[colorlinks=true,linkcolor=black]{hyperref}
\usepackage{listings}
\usepackage{url}


\usepackage[top=2cm, bottom=2cm, left=3cm, right=3cm]{geometry}

\lstset {language = Python,
	numbers = left,
	showspaces = false,
	tabsize = 2,
	showstringspaces = false
	}

\title{Codes correcteurs et cryptosystème de Mc Eliece}
\author{Auclair Pierre}

\begin{document}
	\maketitle

	Le cryptosystème de Mc Eliece est un système de cryptage qui s'appuie sur la théorie des codes correcteurs.
	Il se situe à intersection des soucis de fiabilité et de sécurité de l'information.
	C'est pourquoi nous avons implémenté ce système en Python dans le cadre du sujet transfert et échange.
	La totalité des ressources est disponible ici : \url{https://github.com/kalaspa/mc-eliece}


	\section*{Préliminaires}

		\subsection*{Codes correcteurs}
			%def, principe
			%Principe
			Tout d'abord, définissons quelques notions des codes correcteurs.
			Un code correcteur est l'image C d'une application linéaire f de $\mathbb{F}^{k}$ vers $\mathbb{F}^{n}$.
			On définit, avec les conventions du cours de mathématiques, les matrices génératrices G et de parité H :
			\begin{eqnarray*}
				G &=& Mat(f) \\
				Ker(H) &=& Im(f)
			\end{eqnarray*}

			La distance minimale d du code est le poids de Hamming le plus faible d'un mot non nul du code.
			La capacité de correction t d'un code correcteur vérifie cette relation :
			$$
				t \leq \frac{d-1}{2}
			$$
			Dans la limite de cette capacité de correction, le syndrome d'un mot de $\mathbb{F}^{n}$ est caractéristique de l'erreur, ce qui permet la correction.

		\subsection*{Outils informatiques}
			% bibliothèques matrices, corps finis, polynômes
			Pour démarrer le projet, il a fallu développer des modules pour utiliser des matrices et des polynômes sur des corps finis.
			Pour cela, nous avons utilisé la programmation orientée objet et la surcharge des opérateurs permise par Python.
			Nous avions ainsi des classes de polynômes et de matrices à coefficients aussi bien réels que de $\mathbb{F}_{p^{m}}$.

			Une optimisation que nous avons trouvé consiste à considérer uniquement le cas $p = 2$.
			Ainsi, un élément de $\mathbb{F}_{2^{m}}$ équivalent à un polynôme dans $\mathbb{F}_{2}[X]/P$ peut être stocké comme un nombre en base binaire.
			Les opérations sur ces éléments deviennent des opérations binaires beaucoup plus rapides que l'implémentation plus mathématique.

		\subsection*{Algorithmes supplémentaires}
			%Gauss
			%Berlekamp-Hensel
			Pour compléter le projet, nous avons implémenté les algorithmes de Gauss et de Berlekamp-Hensel.
			En plus du calcul de l'inverse, le pivot de Gauss nous a servi à déterminer le noyau d'une matrice ou un inverse à gauche d'une matrice non carré.
			Quant à l'algorithme de Berlekamp-Hensel, celui permet de vérifier l'irréductibilité d'un polynôme dans un corps fini.
			Étant donné qu'on doit en générer aléatoirement pour chaque clef, son usage était indispensable.

	\section*{Codes de Goppa}

		\subsection*{Définition}
			%Syndrome

		\subsection*{Décodage}
			%Équation clef

		\subsection*{Implémentation}


	\section*{Mc Eliece}

		\subsection*{Principe}
			%Clefs, codage, décodage

		\subsection*{Sécurité}
			 %Syndrome decoding et indistingabilité

		\subsection*{Mise en œuvre}
			%Classe clef






\bibliographystyle{alpha}
\bibliography{ref}
\end{document}
